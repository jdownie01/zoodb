Schema Evolution
================
Maybe we need to create an OID->Schema-OID index?
Due to schema evolution, the Schema-OID in serialized references may be out-dated with respect to
the referenced object. Generally, it may be impossible to create a hollow object from the OID.
Alternative: look up the schema and create a hollow of the latest version?!?!?


COW / Failure tolerance
=======================
What happens if commit fails inbetween data commit and root-page-commit? Or during data commit?
Any newly allocated pages would be lost, unless the rootpage contains would contain the right
file-size. A subsequent write attempt would then allocate new pages not at the end of the file, 
but at the position stored in the rootpage. -> IMPLEMENTED.


COW / Large DB / SSD
====================
COW storage has the advantage that data is written only once. Unfortunately, this can be a 
disadvantage in expensive systems which outsource the log files to high performance drives, which
allows the ODBMS to return from commit after the log files are flushed, real database updates
can be delayed. The COW approach means that we always have to wait for the primary disk to flush.

Luckily this problem does not exist on small devices which do not have separate high-speed disk,
furthermore. It also does not exist where SSD are used for the whole database.


Paging
======

Paging is mainly exploited for indices.

Deserialize whole page???
Earlier, paging was also used to compress object, in particular, _usedObjects were re-used for
all object written in one stream. However, this disallowed random access as it happens during 
queries.
Especially with using multiple consequtive pages even for small objects (as we do currently),
this would require reading all previous object to ensure completeness of _usedObjects.


Indices
-------


Objects
-------
Multi-page objects. 
Separated by class.
All objects from a class in a continuous stream of pages. 





Usage of indices
================

Main indices
------------
There is one main index that maps from OID to page/offset. This is important to look up references,
which are implemented through OIDs.

There is a reverse indexing mechanism: For each Class there is an index from page/offset to OID.
This is important for class based operations: Queries and schema evolution.
For queries it is only important, if no attribute in the query is indexed. It allows finding all
instances of a particular class, without having to look up all objects. Discussion: It would also
be possible (but less useful) to have an index from OID to Schema-ID. 
On rotational drives (e.g. no SSD), this index also allows pure sequential read. 

The latter indexing can also be used as (or to support an) free-space manager.
 
QUESTIONS
A problem that 
remains to be solved here is concerning objects that span multiple pages. How can the secondary
object pages be recognized? Store them as well in the Schema-index?

NON-UNIQUE ordering
If we decide to store all pages that belong to an OID in the index, the index contains many 
OID-page pairs. But which is the starting page? Simply the first one. Even with using a freespace
manager, the pages allocated during the write process for a single object should always be
ascending. That is, because the freespace manager should never be updated during the writing of
(a single) object.



Query-indices:
--------------


COW-indices
-----------
COW indices allow creating an iterator that represents a consistent snapshot of an index. This is
important for the (optional!) JDO feature, that a query result should not change, even if 
matching object are added or removed.
It may also be useful for concurrency, e.g. managing multiple parallel transactions.


Discussion of BitMap indices
===============================
A binary map does not store keys, but only if a certain key is used or not.
By definition, a BitMap is a unique index.
Storing the keys is quite efficient, for example 64 keys in one LONG. The values are stored in a 
separate array. the number of values can be stored separately or derived from the number of bits in 
the batch.
The batches are organized in a hierarchy. 


Schema
======
We assume that most schemas are used in a particular session. Therefore they are all loaded at
database connection time.

Lessons learned
===============
- String.getBytes() and 'new String(byte[])' are extremely slow, they even include synchronization.
  Use 'new String(char[])' instead.
  
- ArrayList is faster than BucketList! Even though ArrayList doesn't scale because of array copying,
  it is still much faster than BucketList for 1.000.000 entries.
  
- Boolean is not a Number!!!
